
# [pygame.surfarray][1]

pygame module for accessing surface pixel data using array interfaces.

Functions to convert between [NumPy](https://numpy.org/) `arrays` and [Surface](/doc/Surface.md) `objects`.  
This module will only be functional when pygame can use the external `NumPy` package.  
If NumPy can't be imported, surfarray becomes a MissingModule object.

Every `pixel` is stored as a `single integer value` to represent the red, green, and blue colors.  
The `8-bit` images use a value that looks into a `colormap`.  
Pixels with higher depth use a `bit packing` process to place three or four values into a single number.

The arrays are indexed by the X axis first, followed by the Y axis.  
`[x, y]`.  
Arrays that treat the pixels as `a single integer` are referred to as `2D arrays`.

This module can also separate the `red, green, and blue` color values into separate indices.  
These types of arrays are referred to as `3D arrays`, and the last index is 0 for red, 1 for green, and 2 for blue. `[r, g, b]`.  
`[x, y, color]`.

The pixels of a 2D array as returned by [array2d()](#array2d) and [pixels2d()](#pixels2d) are mapped to the specific surface.  
Use [pygame.Surface.unmap_rgb()](/doc/Surface.md/#unmap_rgb) to convert to a color, and [pygame.Surface.map_rgb()](/doc/Surface.md/#map_rgb) to get the surface specific pixel value of a color.  
Integer pixel values can only be used directly between surfaces with matching pixel layouts (see [pygame.Surface](/doc/Surface.md)).

All functions that refer to "array" will copy the surface information to a new numpy array. All functions that refer to "pixels" will directly reference the pixels from the surface and any changes performed to the array will make changes in the surface.  
As this last functions share memory with the surface, this one will be locked during the lifetime of the array.

### .array2d()

***Copy*** pixels into a 2d array.

```python
array2d(Surface) -> array
```

***Copy*** the [mapped](/doc/Surface.md/#map_rgb) (raw) pixels from a Surface into a 2D array.  
The `bit depth` of the surface will control the `size` of the integer values, and will work for any type of pixel format.

This function will `temporarily lock` the Surface as pixels are copied (see the [pygame.Surface.lock()](/doc/Surface.md/#lock) - lock the Surface memory for pixel access method).

### .pixels2d()

***Reference*** pixels into a 2d array.

```python
pixels2d(Surface) -> array
```

Create a new 2D array that directly ***references*** the pixel values in a Surface.  
Any changes to the array will affect the pixels in the Surface.  
This is a `fast` operation since `no` data is `copied`.

Pixels from a `24-bit` Surface `cannot` be referenced, but `all other` Surface bit depths `can`.

The Surface this references will `remain locked` for the lifetime of the array, since the `array` generated by this function `shares memory` with the `surface`.  
See the [pygame.Surface.lock()](/doc/Surface.md/#lock) - lock the Surface memory for pixel access method.

### .array3d()

***Copy*** pixels into a 3d array.

```python
array3d(Surface) -> array
```

Copy the pixels from a Surface into a 3D array.  
The `bit depth` of the surface will control the `size` of the integer values, and will work for any type of pixel format.

This function will `temporarily lock` the Surface as pixels are copied (see the [pygame.Surface.lock()](/doc/Surface.md/#lock) - lock the Surface memory for pixel access method).

### .pixels3d()

***Reference*** pixels into a 3d array.

```python
pixels3d(Surface) -> array
```

Create a new 3D array that directly ***references*** the pixel values in a Surface.  
Any changes to the array will affect the pixels in the Surface.  
This is a `fast` operation since `no` data is `copied`.

This will `only` work on Surfaces that have `24-bit` or `32-bit` formats.  
Lower pixel formats cannot be referenced.

The Surface this references will `remain locked` for the lifetime of the array, since the `array` generated by this function `shares memory` with the `surface`.  
See the [pygame.Surface.lock()](/doc/Surface.md/#lock) - lock the Surface memory for pixel access method.

### .array_alpha()

***Copy*** pixel alphas into a 2d array.

```python
array_alpha(Surface) -> array
```

Copy the ***pixel alpha*** values from a Surface into a 2D array.  
This will work for any type of Surface format.  
Surfaces `without a pixel alpha` will return an array with `all opaque` values.

This function will `temporarily lock` the Surface as pixels are copied.  
(see the [pygame.Surface.lock()](/doc/Surface.md/#lock)).

### .pixels_alpha()

***Reference*** pixel alphas into a 2d array.

```python
pixels_alpha(Surface) -> array
```

Create a new 2D array that directly ***references*** the `alpha` values in a Surface.  
Any changes to the array will affect the pixels in the Surface.  
This is a fast operation since no data is copied.

This can `only` work on `32-bit` Surfaces with a `per-pixel alpha` value.

The Surface this references will `remain locked` for the lifetime of the array, since the `array` generated by this function `shares memory` with the `surface`.  
See the [pygame.Surface.lock()](/doc/Surface.md/#lock).

### .array_red()

```python
array_red(Surface) -> array
```

***Copy*** the pixel `red` values from a Surface into a 2D array.  
This will work for any type of Surface format.  
This function will `temporarily lock` the Surface as pixels are copied.  
(See the [pygame.Surface.lock()](/doc/Surface.md/#lock))

### .pixels_red()

```python
pixels_red(Surface) -> array
```

Create a new 2D array that directly ***references*** the `red` values in a Surface.  
Any changes to the array will affect the pixels in the Surface.  
This is a fast operation since no data is copied.

This can `only` work on `24-bit` or `32-bit` Surfaces.

The Surface this references will `remain locked` for the lifetime of the array, since the `array` generated by this function `shares memory` with the `surface`.  
See the [pygame.Surface.lock()](/doc/Surface.md/#lock).

### .array_green()

```python
array_green(Surface) -> array
```

***Copy*** the pixel `green` values from a Surface into a 2D array.
This will work for any type of Surface format.  
This function will `temporarily lock` the Surface as pixels are copied.  
(See the [pygame.Surface.lock()](/doc/Surface.md/#lock))

### .pixels_green()

```python
pixels_green(Surface) -> array
```

Create a new 2D array that directly ***references*** the `green` values in a Surface.  
Any changes to the array will affect the pixels in the Surface.  
This is a fast operation since no data is copied.

This can `only` work on `24-bit` or `32-bit` Surfaces.

The Surface this references will `remain locked` for the lifetime of the array, since the `array` generated by this function `shares memory` with the `surface`.  
See the [pygame.Surface.lock()](/doc/Surface.md/#lock).

### .array_blue()

```python
array_blue(Surface) -> array
```

***Copy*** the pixel `blue` values from a Surface into a 2D array.  
This will work for any type of Surface format.  
This function will `temporarily lock` the Surface as pixels are copied.  
(See the [pygame.Surface.lock()](/doc/Surface.md/#lock))

### .pixels_blue()

```python
pixels_blue (Surface) -> array
```

Create a new 2D array that directly ***references*** the `blue` values in a Surface.  
Any changes to the array will affect the pixels in the Surface.  
This is a fast operation since no data is copied.

This can `only` work on `24-bit` or `32-bit` Surfaces.

The Surface this references will `remain locked` for the lifetime of the array, since the `array` generated by this function `shares memory` with the `surface`.  
See the [pygame.Surface.lock()](/doc/Surface.md/#lock).

### .array_colorkey()

Copy the colorkey values into a 2d array.

```python
array_colorkey(Surface) -> array
```

Create a new array with the colorkey transparency value from each pixel.  
If the pixel matches the colorkey it will be fully transparent (0); otherwise it will be fully opaque (255).

This will work on any type of Surface format.  
If the image has no colorkey a solid opaque array will be returned.

This function will temporarily lock the Surface as pixels are copied.

### .make_surface()

Copy an array to a new surface.

```python
make_surface(array) -> Surface
```

Create a new Surface that best resembles the data and format on the array.  
The array can be 2D or 3D with any sized integer values.  
Function `make_surface` uses the array struct interface to acquire array properties, so is `not` limited to just `NumPy` arrays.  
See [pygame.pixelcopy](/doc/pixelcopy.md).

### .blit_array()

Blit directly from a array values.

```python
blit_array(Surface, array) -> None
```

Directly copy values from an array into a Surface.  
This is faster than converting the array into a Surface and blitting.  
The array must be the `same dimensions` as the Surface and will completely `replace all` pixel values.  
Only `integer`, `ASCII character` and `record` arrays are accepted.

This function will `temporarily lock` the Surface as the new values are copied.

### .map_array()

Map a 3d array into a 2d array.

```python
map_array(Surface, array3d) -> array2d
```

Convert a 3D array into a 2D array.  
This will use the given `Surface format` to control the conversion.  
`Palette` surface formats are supported for NumPy arrays.

[1]:https://www.pygame.org/docs/ref/surfarray.html

< End >
